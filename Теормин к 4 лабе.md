# **Этапы компиляции**
**Предварительная обработка** (Preprocessing): Препроцессор обрабатывает директивы #include, #define и другие, удаляет комментарии, расширяет макросы и подключает заголовочные файлы.

**Компиляция (Compilation)**: Компилятор преобразует код, полученный после препроцессора, в код ассемблера. Он проверяет синтаксис, семантику и ошибки времени компиляции.

**Ассемблирование (Assembly)**: Ассемблер преобразует код ассемблера в машинный код и создает объектные файлы (например, с расширением .o или .obj).

**Компоновка (Linking)**: Компоновщик связывает все объектные файлы, разрешает внешние ссылки и собирает их в один исполняемый файл (.exe, .elf) или библиотеку. 


### компилятор
- поступает исходный код на с++ после препроцессора
- с помощью компилятора можно получить наш код в двоичном виде или в assembler-е.
- на этапе компиляции не важно, существует ли реализация ф-ции, главное, чтобы было объявление.
- анонимный namespace на этапе линковки запрещает передачу в другие объектные файлы
- в заголовочный файл кладем только то, что нужно во всех файлах.

# абстракция 
- придание объекту характеристик, которые четко определяют его концептуальные границы, 
отличая от всех других объектов. Основная идея состоит в том, чтобы отделить способ использования составных объектов данных
от деталей их реализации в виде более простых объектов.

# инкапсуляция 
- связывает данные и методы работы с этими данными в единую логическую единицу, (сокрытие внутренних деталей реализации 
от внешнего мира). Класс объединяет данные и методы работы с этими данными. Данные мы прячем за реализацией

# класс
- универсальный, комплексный тип данных, состоящий из тематического единого набора "полей" и "методов"

# Специальные методы классов
## Constructor
- используется для инициализации объекта(обеспечивает инвариант)
- название совпадает с классом
- **виды конструкторов**
    - **default constructor** (без аргументов)
    - **parameterized constructor** (принимает аргументы, инициализирующие поля объекта)
    - **copy constructor** (создание нового объекта, копируя из сущ. объекта)
    - **move constructor** (Позволяет перемещать ресурсы из одного объекта в другой, что более эффективно, чем копирование.)

## Rule of three
- если определен хотя бы один из трех методов, надо и остальные тоже определить
1) Destructor
2) Copy constructor
3) Copy assignment operator

Правило пяти добавляет Move конструктор и Move assignment operator

## Диструктор
- Вызывается при уничтожении объекта для освобождения ресурсов (например, памяти). Если вы не определили свой деструктор, компилятор предоставит неявно сгенерированный деструктор по умолчанию.

```cpp
~имя_класса() 
{
    // код деструктора
}
```

# Перегрузка операторов
1. **не должна противоречить здравой логике**
2. как член класса или как глобальная функция
3. [],(),->,= можно перегружать только как члены класса
4. ввод(>>) и вывод(<<) всегда глобальные функции
5. операторы **::** , **(.*)** (доступ к члену-указателю по указателю) , **.** (доступ к члену класса) , **?:**, **sizeof** перегружать нельзя
6. новые операторы делать нельзя (на уровне компиляции зафиксировано)

```cpp
Point operator+(const Point& other) const {
    return Point(x + other.x, y + other.y);
}
```

# vector (класс)
- принадлежит библиотеке шаблонов stl
- прокаченный дин массив сам следит за выделением памяти, скорость та же, легкое добавление элемента в начало, конец, середину
- при обращении по нес. индексом либо мусор, либо ошибка

## методы
**push_back** - добавление в конец массива
**size** - кол-во элементов
**at** - получить доступ к i-элементу без риска выйти за границу вектора, однако он медленее, чем оператор **[]**
**clear** - очистить от всех элементов
**pop_back** - удалить последний элемент
**capacity** - возвращает вместимость вектора
**reserve(n,x)** - сколько должна быть вместимость, чем заполнить
**shrink_to_fit()** - выравнивает capacity по size
**empty()** - true/false есть ли элементы в векторе
**resize(n,x)** - изменить вместимость, чем заполнить
**insert()** - вставка элемента в вектор в любое место !работает через итератор
**erase()** - стереть i-элемент !работает через итератор
**begin** - возвращает итератор,указывающий на первый элемент вектора
**end()** - указывает на область в памяти сразу после последнего элемента массив
**cbegin** и **cend** - те же самые, только возвращают константные значения

## добавление элемента:
вместимость увеличивается не на 1, а на несколько (в основном на 2)

# итераторы
- итераторы для каждого контейнера разные

```cpp
vector<int> myVector;
vector<int>::iterator it;
it = myVector.begin(); // указывает на первый эл вектора

std::cout << *it << std::endl; // выведет первый элемент вектора
```

