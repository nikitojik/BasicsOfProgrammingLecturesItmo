# **Этапы компиляции**
**Предварительная обработка** (Preprocessing): Препроцессор обрабатывает директивы #include, #define и другие, удаляет комментарии, расширяет макросы и подключает заголовочные файлы.
**Ошибки на этапе препроцессора** возникают из-за неправильного использования директив (команд, начинающихся с #), таких как синтаксические ошибки, ошибки в использовании #define, #include или #if, неправильное расположение директив, а также из-за несовпадения синтаксиса или использования неверных имен файлов. 

**Компиляция (Compilation)**: Компилятор преобразует код, полученный после препроцессора, в код ассемблера. Он проверяет синтаксис, семантику и ошибки времени компиляции.

Синтаксические ошибки: Нарушение правил грамматики языка программирования, например, опечатки, пропущенные символы (точка с запятой, скобки) или неправильная структура операторов.
Пример: Цикл for(;;) является синтаксически неверным, поскольку в нем не хватает необходимых частей.
Семантические ошибки: Код написан синтаксически правильно, но имеет смысловую ошибку, например, использование переменной до ее объявления, попытка присвоить значение переменной только для чтения или несоответствие типов данных.

**Ассемблирование (Assembly)**: Ассемблер преобразует код ассемблера в машинный код и создает объектные файлы (например, с расширением .o или .obj).
Основные типы ошибок при ассемблировании
Синтаксические ошибки: Ассемблер не может понять команду из-за неправильного написания.
Примеры: неверные ключевые слова, неправильное использование синтаксиса команд, ошибки в регистрах или адресах.

Ошибки, связанные с метками и переменными:
Неопределенные символы: попытка использовать метку или переменную, которая не была объявлена в коде.

Ошибки в адресации: неправильное указание адресов памяти, например, при использовании неправильного типа сегмента.

Неправильное использование директив: например, попытка использовать директиву для одного типа данных с другим типом данных.
Неверные параметры директив: например, неправильное число или тип аргументов для директивы.

Ошибки, связанные с обработкой файлов:
Недоступность входных файлов: если ассемблер не может найти или прочитать входной файл (например, из-за опечатки в имени файла).
Ошибки записи в выходной файл: например, если нет прав на запись в целевую директорию.

**Компоновка (Linking)**: Компоновщик связывает все объектные файлы, разрешает внешние ссылки и собирает их в один исполняемый файл (.exe, .elf) или библиотеку. 
«Неопределенный символ» (Undefined symbol / undefined reference)
Причина: Вы используете функцию или переменную, но линковщик не может найти ее определение. Это может произойти, если:
Вы забыли скомпилировать файл, где находится определение, или добавить его в список файлов для линковки.
Библиотека, содержащая определение, не была подключена к проекту.
Вы забыли включить заголовочный файл.
Решение: Убедитесь, что файл с определением функции или переменной скомпилирован и включен в процесс линковки, а также что необходимые библиотеки подключены.

Дублирование символов (multiple definition)
Причина: Одна и та же функция или переменная определены в нескольких объектных файлах. Например, если вы включили определение в заголовочный файл, а затем подключили этот заголовочный файл в нескольких .cpp файлах.
Решение: Перенесите определения в .cpp файлы и используйте заголовочные файлы только для объявлений (прототипов) функций и объявления переменных (с использованием extern).

### компилятор
- поступает исходный код на с++ после препроцессора
- с помощью компилятора можно получить наш код в двоичном виде или в assembler-е.
- на этапе компиляции не важно, существует ли реализация ф-ции, главное, чтобы было объявление.
- анонимный namespace на этапе линковки запрещает передачу в другие объектные файлы
- в заголовочный файл кладем только то, что нужно во всех файлах.

# абстракция 
- придание объекту характеристик, которые четко определяют его концептуальные границы, 
отличая от всех других объектов. Основная идея состоит в том, чтобы отделить способ использования составных объектов данных
от деталей их реализации в виде более простых объектов.

# инкапсуляция 
- связывает данные и методы работы с этими данными в единую логическую единицу, (сокрытие внутренних деталей реализации 
от внешнего мира). Класс объединяет данные и методы работы с этими данными. Данные мы прячем за реализацией

# класс
- универсальный, комплексный тип данных, состоящий из тематического единого набора "полей" и "методов"

# Специальные методы классов
## Constructor
- используется для инициализации объекта(обеспечивает инвариант)
- название совпадает с классом
- **виды конструкторов**
    - **default constructor** (без аргументов)
    - **parameterized constructor** (принимает аргументы, инициализирующие поля объекта)
    - **copy constructor** (создание нового объекта, копируя из сущ. объекта)
    - **move constructor** (Позволяет перемещать ресурсы из одного объекта в другой, что более эффективно, чем копирование.)

## Rule of three
- если определен хотя бы один из трех методов, надо и остальные тоже определить
1) Destructor
2) Copy constructor
3) Copy assignment operator

Правило пяти добавляет Move конструктор и Move assignment operator

## Диструктор
- Вызывается при уничтожении объекта для освобождения ресурсов (например, памяти). Если вы не определили свой деструктор, компилятор предоставит неявно сгенерированный деструктор по умолчанию.

```cpp
~имя_класса() 
{
    // код деструктора
}
```

# Перегрузка операторов
1. **не должна противоречить здравой логике**
2. как член класса или как глобальная функция
3. [],(),->,= можно перегружать только как члены класса
4. ввод(>>) и вывод(<<) всегда глобальные функции
5. операторы **::** , **(.*)** (доступ к члену-указателю по указателю) , **.** (доступ к члену класса) , **?:**, **sizeof** перегружать нельзя
6. новые операторы делать нельзя (на уровне компиляции зафиксировано)

```cpp
Point operator+(const Point& other) const {
    return Point(x + other.x, y + other.y);
}
```

# vector (класс)
- принадлежит библиотеке шаблонов stl
- прокаченный дин массив сам следит за выделением памяти, скорость та же, легкое добавление элемента в начало, конец, середину
- при обращении по нес. индексом либо мусор, либо ошибка

## методы
**push_back** - добавление в конец массива
**size** - кол-во элементов
**at** - получить доступ к i-элементу без риска выйти за границу вектора, однако он медленее, чем оператор **[]**
**clear** - очистить от всех элементов
**pop_back** - удалить последний элемент
**capacity** - возвращает вместимость вектора
**reserve(n,x)** - сколько должна быть вместимость, чем заполнить
**shrink_to_fit()** - выравнивает capacity по size
**empty()** - true/false есть ли элементы в векторе
**resize(n,x)** - изменить вместимость, чем заполнить
**insert()** - вставка элемента в вектор в любое место !работает через итератор
**erase()** - стереть i-элемент !работает через итератор
**begin** - возвращает итератор,указывающий на первый элемент вектора
**end()** - указывает на область в памяти сразу после последнего элемента массив
**cbegin** и **cend** - те же самые, только возвращают константные значения

## добавление элемента:
вместимость увеличивается не на 1, а на несколько (в основном на 2)

# итераторы
- итераторы для каждого контейнера разные

```cpp
vector<int> myVector;
vector<int>::iterator it;
it = myVector.begin(); // указывает на первый эл вектора

std::cout << *it << std::endl; // выведет первый элемент вектора
```

# std::ios::binary
Двоичный поток — это упорядоченная последовательность символов, которая позволяет прозрачно записывать внутренние данные. Данные, считываемые из двоичного потока, всегда соответствуют данным, ранее записанным в этот поток, за исключением того, что реализация позволяет добавлять неопределённое количество нулевых символов в конец потока. Широкий двоичный поток не обязательно должен заканчиваться в начальном состоянии сдвига.