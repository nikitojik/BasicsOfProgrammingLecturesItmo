# Архитектура ЭВМ Фон Неймана
Современные компьютеры в основном основаны на архитектуре Фон Неймана (иногда — Гарвардской). Идея простая: есть процессор, есть память, есть устройства ввода-вывода, и программа — это набор команд и данных, которые лежат в памяти, а процессор их по очереди выполняет

Память компьютера состоит из ячеек, каждой из которых присвоен номер — адрес. Любая из ячеек доступна компьютеру в любой момент времени, и он может обратиться к её содержимому по адресу.

Память компьютера используется как для хранения данных, так и для хранения программы. Команды и числа кодируются в двоичной системе счисления. Над командами можно производить те же операции, что и над числами. На этом принципе основана трансляция — перевод текста программы с языка высокого уровня на язык конкретной ЭВМ.

Компьютером управляет программа, которая состоит из команд, хранящихся в последовательных ячейках памяти. Каждая команда выполняет операцию из набора операций, доступных компьютеру.

Компьютер выполняет команды последовательно — от первой к последней, согласно порядку следования в программе.
## Что такое трансляция
**Трансляция** — это перевод программы, написанной на языке высокого уровня (C++, Python, Pascal...), в программу на машинном языке (последовательность бит), понятную конкретному процессору.
Трансляция включает несколько этапов.
### 1. **Компиляция**
Преобразование исходного текста в машинный код или в промежуточное представление.
Пример:  
`a = b + c;` → набор машинных команд.
### 2. **Ассемблирование** (если используется ассемблер)
Ассемблер переводит мнемоники (типа `MOV AX, 1`) в бинарный код процессора.
### 3. **Линковка**
Объединение разных частей программы и библиотек.

---
# Процессы и потоки
## Процесс
### Независимое адресное пространство процесса
Операционная система запускает нашу программу в виде **процесса**.
**Процесс** — это выполняющаяся в данный момент программа. Каждому процессу ОС выделяет **свою область памяти**, которая недоступна другим процессам. Это значит:
- процесс A не может читать/портить память процесса B;
- падение одного процесса не рушит другие.
То есть у процесса — **своя RAM**, своё пространство код+данные+стек+куча.
### Объекты ядра процесса
Процессу принадлежат системные объекты, которыми управляет ОС

## Потоки
**Поток** - единица выполнения внутри процесса. Все потоки разделяют ресурсы процесса, но имеют свои собственные структуры. У потока есть набор команд и стек.
### Набор команд
Это то, что поток выполняет: инструкция за инструкцией.
У процесса может быть:
- один поток (однопоточная программа)
- много потоков (браузер, игры)
Все потоки разделяют:
- память процесса,
- открытые файлы,
- глобальные переменные.
### Стек
У каждого потока есть **свой собственный стек**.
Стек хранит:
- локальные переменные функций,
- параметры функции,
- адрес возврата
- состояние выполнения.
Если бы стек был общий, потоки разрушали бы друг другу данные.
Один процесс может иметь много потоков, они разделяют общее адресное пространство, но у каждого — свой стек.
![[Pasted image 20251127001151.png]]


---

# Виртуальное адресное пространство

Для каждого процесса ОС создаёт иллюзию, что у него есть «своя» сплошная память от нулевого адреса и до какого-то максимального. На самом деле это не так:
1. У каждого процесса — **своё виртуальное адресное пространство**.
2. Это пространство **отображается (мапится)** на физическую память с помощью специальной структуры — **page table (таблица страниц)**.
3. Благодаря этому:
    - процессы **изолированы** друг от друга;
    - можно делать **memory-mapped files** (файлы, видимые как участки памяти);
    - ОС может организовывать **swapping** — выгружать неиспользуемые страницы на диск;
    - обеспечивается **защита**: нельзя просто так лезть в память ядра или соседнего процесса.
### что такое _memory-mapped file_
**memory-mapped file** = файл, доступный как массив памяти.
Это механизм ОС, который позволяет работать с файлом так, будто он находится **прямо в оперативной памяти**.

Обычно мы читаем файл так:
```cpp
read(file, buffer, length)
```
Но при memory-mapping ОС:
- выделяет участок виртуальной памяти;
- «привязывает» его к файлу на диске;
- и программа может работать с ним **как с обычным массивом в памяти**.

Пример (псевдокод):
```cpp
char* data = mmap("data.bin"); 
data[0] = 'A'; // изменяем файл прямо через память`
```
---

## Как программа представлена в памяти

![[Pasted image 20251127003207.png]]
Этот слайд объясняет **как операционная система делит виртуальное адресное пространство процесса на две части:**
1. пространство ядра (Kernel Space)
2. пространство пользовательской программы (User Mode Space)
И сравнивает разные схемы разделения в Linux и Windows на 32-битных системах.

Каждый 32-битный процесс имеет **4 ГБ виртуальной памяти**  
(адреса от `0x00000000` до `0xFFFFFFFF`).
Эта память _не настоящая физическая_, а **виртуальная**, которую ОС отображает (map) в физическую память по мере необходимости.
Но не весь этот объём доступен программе!  

Часть резервируется под ядро ОС. У каждого процесса свой виртуальный адрес спейс, но Kernel Space — общий

Когда говорят, что у процесса есть:
- **User Space** (свой, уникальный для процесса)
- **Kernel Space** (кажется, как будто тоже свой)
— это _не означает_, что ядро копируется в память каждого процесса.

‼️ **На самом деле ядро загружено один раз** в физическую память.

Но его **виртуальные адреса отображаются одинаково** во _все_ процессы, чтобы ядро могло работать с процессом, не меняя контекст памяти каждый раз.

![[Pasted image 20251127003908.png]]

Если посмотреть на то, как программа разложена по памяти, мы увидим разные **сегменты**:

1. **Text** — машинный код программы (функции).
2. **Data** — инициализированные глобальные и статические переменные.
3. **BSS** — неинициализированные глобальные переменные.
4. **Stack** — стек вызовов.
5. **Heap** — куча (динамическая память).
6. **Memory mapping** — области, куда отображены файлы или разделяемая память.

В презентации есть пример: программа печатает адрес глобальных переменных, строки `"Hello world"`, локальной переменной и функции. По этим адресам можно увидеть, что каждая сущность попадает в свой сегмент: глобальные переменные — в Data/BSS, строковый литерал — в сегмент данных/текста только для чтения, локальная переменная — в стек, адрес функции — в сегмент кода.

---
# Стек вызова

Теперь подробнее про **стек**.
Стек — это область памяти, в которой хранятся данные, связанные с вызовом функций:
### Stack Frame — «кадр стека»
Адрес функции — это просто адрес первой инструкции в сегменте .text
Когда ты вызываешь функцию, для неё создаётся **мини-площадка на стеке**, где она хранит всё своё нужное:
a) **arguments (аргументы)** - числа, которые ты передаёшь в функцию. (Первые **6 аргументов** хранятся НЕ на стеке, а в **регистрах процессора**. Регистр — это маленькая сверхбыстрая ячейка памяти внутри процессора.)
b) **local variables (локальные переменные)** - переменные, объявленные внутри функции.
c) return point (адрес возврата) - куда нужно вернуться после окончания функции.
Каждый вызов функции создаёт новый кадр, а возврат — уничтожает его.

```cpp
int add(int a, int b) {
   return a + b;
}

int main () {
   int result;
   result = add(40, 2);
   return 0;
}```

Когда вызывается `add(40, 2)`, на стек кладётся **кадр стека (StackFrame)**, в котором есть
- аргументы функции `a` и `b`;  (Первые **6 аргументов** хранятся НЕ на стеке, а в **регистрах процессора**. Регистр — это маленькая сверхбыстрая ячейка памяти внутри процессора.)
- локальные переменные (если есть);  
- адрес, куда нужно вернуться после завершения функции. 

Существуют разные **calling conventions**: `cdecl`, `stdcall`, `fastcall` — они задают, кто очищает стек, как передаются аргументы (через стек или регистры)

Процессор использует специальные **регистры** 
- `esp/rsp` — указывает на вершину стека;  
- `ebp/rbp` — начало кадра стека текущей функции;  
- `eax` (или другой регистр) — обычно хранит результат работы функции. 
Результат работы функции лежит в регистре

In the Intel architecture, as in most, the stack grows towards _lower memory addresses_. So the “top” is the lowest memory address in the stack containing live data:

1) return address
2) saved rbp
3) local variables
4) local copies of arguments


---
# Куча (Heap) и динамическая память

Помимо стека, у нас есть **куча** — область памяти для динамически создаваемых объектов. В отличие от стека, где память выделяется и освобождается автоматически при входе/выходе из функции, кучей управляет сам программист. 

Основные отличия кучи от стека
1. В куче можно создавать **большие структуры** и жить они могут сколько угодно — пока вы сами их не удалите.  
2. Управление временем жизни объектов **ручное**: выделили — не забудьте освободить.  

В Си для работы с кучей используются функции из `<stdlib.h>`:  
- `malloc` — выделяет блок памяти;  
- `calloc` — выделяет и обнуляет;  
- `realloc` — изменяет размер уже выделенного блока;  
- `free` — освобождает. :contentReference

Пример из презентации:  

```cpp
int* p1 = (int*)malloc(4 * sizeof(int));
int* p2 = (int*)malloc(sizeof(int[4]));

if (p1) {
    for (int n = 0; n < 4; ++n)
        p1[n] = n * n;
    ...
}
free(p1);
free(p2);
```

Важно помнить несколько вещей

1. `malloc` **не гарантирует** успешное выделение — нужно проверять указатель на `NULL`.  
2. После `free(ptr)` хорошо бы обнулить указатель: `ptr = NULL;`  
3. `free(NULL)` безопасен — он просто ничего не делает.  

Есть ещё пример, где сравниваются `sizeof` разных вещей: самой переменной, указателя, объекта по указателю и массива. Он показывает важную мысль:  
- размер указателя (`sizeof(p)`) фиксирован (обычно 4 или 8 байт),  
- а размер того, на что он указывает (`sizeof(*p)`), зависит от типа

В C++ вместо `malloc/free` чаще используют `new/delete`

```cpp
int* pr = new int;
delete pr;

int* arr = new int[10];
delete[] arr;
````

Тут тоже главное — не забыть вызвать `delete`/`delete[]`.

---

# Segmentation fault — откуда он берётся

Наконец, типичная ошибка при работе с памятью — **segmentation fault**. Это ситуация, когда программа обращается к памяти так, как ей нельзя. В презентации перечислены основные причины:

1. Обращение к **несуществующему адресу**.
2. Обращение к **сегменту**, для которого нет прав (например, в память ядра).
3. Попытка изменить данные в **read-only сегменте** (например, строковый литерал).
4. Доступ по **нулевому указателю** (`nullptr` или `NULL`).
5. Доступ по указателю на уже **освобождённую память** (use-after-free).
6. **Переполнение стека** — слишком глубокая рекурсия или огромный массив на стеке.
7. **Переполнение буфера** — вылезли за границы массива.

В презентации есть два конкретных примера:

1. **Огромный массив на стеке**:
    
    ```cpp
    uint64_t arr[1048570]; // ~8Mb
    arr[10] = 1;
    ```
    
    Массив кладётся в стек, он слишком большой — стек переполняется, и программа падает.
    
2. **Изменение строкового литерала**:
    
    ```cpp
    char local_str[] = "Hello world";
    // char* local_str = "Hello world";
    
    local_str[1] = 'E';
    printf("%s\n", local_str);
    ```
    
    В варианте с `char local_str[]` всё нормально: создаётся изменяемый массив в стеке.  
    А если раскомментировать вариант с `char* local_str = "Hello world";`, строка `"Hello world"` лежит в read-only сегменте, и попытка её изменить приведёт к `segmentation fault`.
    

---

# Про компиляцию

![[Pasted image 20251114145242.png]]
![[Pasted image 20251114145326.png]]
![[Pasted image 20251114145402.png]]
![[Pasted image 20251114145434.png]]
**linkage** — одно из ключевых понятий в компиляции C/C++.  
Linkage определяет **где** имя (функция, переменная, объект) может быть видно **во время линковки**, то есть **какие Translation Units могут ссылаться на один и тот же символ**.
##  1. External linkage
**External linkage** означает:
> Имя доступно из всех единиц трансляции (всех `.cpp` файлов проекта).

Это обычные функции и глобальные переменные без `static`
Проще: linkage = _“уровень видимости имени на этапе линкера”_.
## 2. Internal linkage
**Internal linkage** = имя видно только в _одной_ единице трансляции  
(только в текущем `.cpp`).
Создаётся с помощью `static` или `const` глобальных переменных:
Зачем internal linkage?
- скрыть детали реализации внутри `.cpp`
- уменьшить шансы конфликта имён
- аналог private для глобального уровня
## 3. No linkage
**No linkage** = имя существует только в своем скоупе,  
и к нему нельзя сослаться извне вообще.
1. Локальные переменные
2. Параметры функции
3. Переменные в скоупах
![[Pasted image 20251114150200.png]]


Условная компиляция — это способ отключать и включать части кода на этапе препроцессора, до компиляции.
# Перегрузка функции
Полиморфизм функций - это удобное добавление С++ к возможностям языка С . В т о время как аргументы п о умолчанию позволяют вызывать одну и ту же функцию с различным количеством аргументов, полиморфизм функций, также называемый пере­ грузкой функций, предоставляет возможность использовать несколько функций с одним и тем же именем. Слово полиморфизм означает способность иметь множество форм, следовательно , полиморфизм функций позволяет функции иметь множество форм . Подобным же образом выражение перегрузка функций означает возможность привязки более чем одной функции к одному и тому же имени , таким образом, перегружая имя. Оба выражения означают одно и то же, но мы будем пользоваться вариантом перегрузка функций, как более строгим. С применением перегрузки функций можно разработать семейство функций, которые выполняют в точности одно и то же , но с использовани­ ем различных списков аргументов.
___
Ключевую роль в перегрузке функций играет список аргументов, который также
называется сигнатурой функции. Если две функции испол ьзуют одно и то же количе­
ство аргументов с теми же самыми типами в одном и том же порядке , то функции
имеют одинаковые сигнатуры; при этом имена переменных во внимание не принима­
ются. Язык С++ позволяет определить две функции с одним и тем же именем при усло­
вии , что эти функции обладают разными сигнатурами_ Сигнатуры могут различаться
по количеству аргументов или по их типам, либо по тому и другому.
___
Имейте в виду, что именно сигнатура, а не тип функции, делает возможным ее пе­
регрузку. Например, два следующих объявления несовместимы:
```cpp
// одинаковые сигнатуры, поэтому
// объявления не допускают с я
long gronk(int n, float m); 
double gronk(int n, float m);
```
В С++ нельзя перегружать функцию gronk ( ) подобным образом. Можно иметь раз­
личные возвращаемые типы , но только при условии, что сигнатуры функций отлича­
ются:
```cpp
long gronk (int n, float m);
double gronk (float n, float m);
```Условная компиляция — это способ отключать и включать части кода на этапе препроцессора, до компиляции.
